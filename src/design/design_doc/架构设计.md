---
title: 系统架构设计
prev: 功能点概述
next: 开发计划
---

# 系统架构设计

这里我会描述下整个工具的结构以及为什么我要选择这种结构来搭建。整个架构按照类别分，分为前端架构、后端架构、逻辑架构、实现结构等。下面我会用图的形式来描述，这是一个怎样的系统，同时也会描述为什么要这么做。

## 前端架构

![20221019151045](https://img.jaken.top/image/20221019151045.png)

从图上可以看出来这是一个比较经典的前后端分离架构，由于使用了electron作为桌面化框架，因此添加了electron中间层来承上启下。相比经典的架构，这里我们使用本机的RPC方式通信（考虑到扩展性可能会用http协议通信），整个通信过程是需要经过electron的。

值的注意的是展现层我们采用组件化的思想，分为了资源组件展示库以及前端功能组件库（目前）。资源组件展示库，是将后端提供的抽象资源信息展现成一个HTML组件，而功能组件库则是实现了一些业务组件（例如打开文件等功能，这部分组件适合electron有一定耦合性的）。

在这里Electron层主要是为了可以支持本地化功能，他需要实现一些本地化功能（例如菜单、通用配置、滚动更新、异常退出恢复等能力），此外最关键的他也要承担和服务层对接的能力，设计上我希望Electron可以直接透传服务端的相关接口信息（甚至在有必要时直接调用服务端），Electron要做的最多就是进行一些增强，例如日志等工作。

服务层也就是后端架构这部分我们会在后端在做概述，下面会讨论一些细节，以及为什么要这样设计。

### 前端技术栈选择

- vue3+vite+tsx 这三个作为底层响应式框架，以及组件的开发
- pinia+router+naiveui 用于状态管理、核心路由、通用UI界面的开发
- Milkdown 用作markdown编辑器的基础框架（Markdown组件基于这个框架二次开发，封装）
- node cluster 这是nodejs的创建子进程功能，同时还允许父子进程监听同一个HTTP接口

### 组件化思想

前面简单的概括了组件化思想，我们需要给每一个资源对象实现一个组件用于展示，这个组件本身会提供一系列的接口或者props来获取外界的信息（类似于UI框架的一个表格组件这种）。这么做的原因除了为了有更好的封装性外，最主要的是我希望这个工具他可以有一些其他的子工具（例如Markdown编辑器），这样分离后我们就很容易将这些组件复用了。

### Monorepo

前端我们将使用Monorepo这种大仓的开发模式，这也是最近了解到的类似Vue3和Milkdown的这种开发方式。[https://zhuanlan.zhihu.com/p/77577415](这篇知乎讲了这种模式的概念)，其实就类似大仓开发的方式，我们会把每个组件都打成一个小包，最后在前端引用这个组件。我简单的调研了一下他的实现方式，可以[https://pnpm.io/zh/workspaces](使用pnpm的workspace功能)这篇文章也讲了pnpm如何进行Monorepo开发。

### 使用Electron

在这个时间有很多新的技术可以左右我使用Electron作为跨平台桌面的开发，但是我发现很多新兴的桌面开发框架并没有非常好的社区生态，至少在国内是这样的。由于我并不是一个全职前端，因此我需要在一些精力上作出取舍。Electron主要负责了一些桌面端的增强（未保存数据的恢复能力、菜单配置等功能、拖拽文件、最近打开、外链等功能），其余几乎所有功能都是交给服务端完成的（Electron只做了数据的转发，我们甚至想让他连转发都不做，通过HTTP请求直接有web端发起，这是一个开放软件因此我们提供HTTP接口可以方便大家的扩展和增强）。

### *使用NodeCluster

NodeCluster模块可以帮助我实现，父子进程监听同一个端口，目前我再评估是否需要使用此方式来实现Electron唤起服务端相关功能。

## 后端架构

![20221019161640](https://img.jaken.top/image/20221019161640.png)

后端总体比较简洁，目前采用Java作为开发语言，使用Spring全家桶、Spring Native编译成本地镜像，减轻运行时系统压力。经典的MVC架构这里也不做过多阐述。

### 框架选型

- Hutool：目前主要使用他对文件IO的封装，有些功能可以使用他来实现
- Spring MVC：我们通过

## 前后端交互

我大概了解了思源笔记的前后端交互逻辑，和我原先预想的不同。他直接将electron作为一个浏览器，后台基于go编写了一个web服务。交互的逻辑上我打算让界面更加依赖于Electron，而后端则专注于Restful接口的相关通信。同时通过NodeCluster模块在Electron中fork一个java的native进程，并且让他们监听同一个端口最终实现RPC通信等功能。

### Electron唤起Java的方式

我参考了思源的设计逻辑，大概就是通过启动子进程后，检测返回状态，如果出现了返回则根据不同的code打印不同的错误日志（需要调研java这边是否支持）