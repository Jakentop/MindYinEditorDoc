---
title: 组件通用能力
prev: ./
next: Markdown组件能力概述
---

# 组件通用能力

首先我们定义组件需要具备的通用能力（目前按照Markdown作为原型），随后我们会根据这种通用能力实现Markdown编辑组件（基于Milkdown实现）。

## 通用基础能力

这些能力是整个工具中最基本的能力，类似于对象的CRUD。我们通过这种结构让上层业务屏蔽掉下层枯燥而又重复的IO机制。这块能力都是由后端资源服务器实现的，资源服务器引入的目的你可以理解为给上层业务提供一个抽象的访问逻辑，并不需要关心是何种存储方式。

![20221011102033](https://img.jaken.top/image/20221011102033.png)

### 资源对象

每一种类型的资源都有他的对应的资源对象。这个对象用来标识一个资源的所有元数据，而笔记工具的渲染过程其实是资源对象的渲染过程。这里暂时定义一些常用的元数据：
- 资源对象唯一标识
- 资源对象的类型标识（根据类型可以确定他是那种资源并且如何渲染等）
- 资源对象物理类型标识（标识这个对象是存在何种物理存储中的）
- 资源对象原始资源位置（包括了获取这个资源的途径和方式）
- 资源对象的物理名称（即他的源文件的名称，当我们导出对象时就是用该名称）
- 资源对象的别名（在笔记工具中定义的其他名称，可以有多个方便检索）
- 资源对象的标签（可以有多个）
- 资源对象的物理元数据（创建人，创建时间，修改时间，扩展字段等）
- 资源对象关联的关系记录

### 片段对象

片段对象是资源对象的细粒度行为，例如一个Markdown资源中的每一个段落都可以是一个片段对象；一个导图中的每个节点也都是一个片段对象。片段对象是资源对象的子集，因此他支持所有资源对象的能力，同时还提供了一些额外的行为，例如片段在资源对象中定位，查找等，以及一些独立的行为。**注意：我们认为资源对象可以关联和引用，也就代表了片段对象也支持这些行为**

### 关系对象

需要实现关系模块相关功能，需要我们除了资源对象、片段对象外，还需要一个特殊的对象组织资源和片段之间的关系，因此我们定义了一个关系对象，他包括了例如一个Markdown片段中包括了哪些引用。通过这个对象我们可以实现块级索引等功能。关系对象是有上层业务层创建并维护的，因此这里不做过多的阐述。

### 物理对象IO接口

当我们需要读取或者修改对象时，需要对这个对象作出实质性的改动，此时就设计了他的IO接口。其中包括对象内容的读取、修改、删除、移动、打开等功能，这里我简单罗列下，其中每个点都需要考虑如何设计。

此接口将会对接物理层面的IO接口，即从什么途径查询获取数据（此处的数据是原始数据可能是字符串也可能是二进制文件）。物理对象IO接口实现可能包括（文件系统IO、缓存IO、SQL IO、网络IO等）下面罗列出一些需要实现的基本功能。

- 资源对象全量读取，滚动读取（可能对于一些卡片笔记等不需要滚动读取）
- 资源对象全量更新操作，局部更新操作（全量更新适合小文件，局部适合大文件）
- 资源对象移动，复制。相应的移动和复制功能。

### 资源对象IO接口

每种资源对象都会有自己的IO方式，这种IO需要对接物理对象的IO接口。所有的业务层都是通过访问该接口与资源服务器交互，最终获取或者保存资源的，资源对象IO对于每种资源都需要有独立的实现，注意资源对象IO可能会对接多个物理对象（最常见的场景就是多级缓存）这里罗列一下资源IO包括的基础功能。

- 资源的CRUD，增删改查。
- 资源的位置移动（逻辑位置、物理位置）
- 资源元数据的CRUD等。
- **资源片段能力，例如Markdown可以被细分成一个一个的段落，导图则可以细分成每一个节点**。这些功能的定义是对资源对象粒度的二次拆分。我们需要在资源对象IO中实现这些更细粒度的访问。这可以使得我们实现业务中的资源渲染和关系能力。
- 需要支持根据当前信息反向获取资源/片段对象引用信息（例如在Markdown中的光标出我可以获取他属于哪个资源对象，以及哪个片段对象）

## 通用业务能力

除了上文中的基础能力外，本质上我们需要实现一些基础的业务功能，例如资源的渲染、资源的关系记录、资源的修改、资源事务支持、资源的回溯（撤销功能）等，这些功能首先会基于底层的基础能力，同时也会有部分交互需要涉及到后端业务处理能力等。

### 资源渲染

在前面的理念中我希望可以实现一个具有深度融合的多种形式资源的展示，资源渲染需要实现除了本身的渲染外，还需要实现关系模块的渲染。你可以理解为我希望在Markdown中的某一块嵌入一个导图。**我称他为嵌套渲染，即某一个资源对象A中的某个资源片段可以是另一个资源/片段对象**。这是这个工具中的核心功能点，因此在后期技术选型是我们需要找到一个可以支持深度定制化的框架。

除了嵌套渲染外，我们还需要支持关联渲染。在关系模块中我阐述了关联和引用的区别，前者的嵌套渲染，其实是实现了关系模块中的引用关系。而后者的关联渲染则是实现了关联关系，**你可以理解成每一个资源/片段对象都可以关联一个或多个资源/片段对象**。

除了基础渲染外，我们还需要考虑自动刷新能力。例如某一个导图节点引用了一个Markdown，而这个Markdown打开并且发生了修改。此时就需要进行自动刷新了。

### 关系记录

每一个资源/片段对象都会有自己的关系记录，我们需要一个独立的数据结构来维护这种记录，因此关系对象出现了。在这里需要定义一些维护方法，例如根据资源对象ID查询关联关系，维护某个资源对象中的关系等功能。

### 资源修改

资源修改，我们强制他只可以修改当前资源的相关内容。对于这个资源对象引用的所有其他资源对象都是只读的，当然在需要时提供一个按钮允许用户打开这个资源编辑。

> 这一功能是早期的实现方案,我们希望在今后可以直接实现在一个资源对象中编辑另一个引用的资源对象。但这也就意味着需要两个焦点同时对一个文件进行修改，这就需要引入多人协同的一致性算法了。后期考虑商业化时可以实现。

### 资源回溯

其实这个功能就类似撤销和重做，组件中的每一步操作都需要按照特定的格式记录下来。并且可以生成对应的逆向操作（这块可以考虑用状态管理的思想，逆操作太复杂了了）也就是记录每个文档最近100个或者1000个状态，然后回溯他，但是我并不大了解对于大文件改如何实现这个功能。

实际上我们实现资源回溯可以理解为，所有打开的资源都有一个撤销栈（类似pinia这种状态管理机），我们支持他恢复到任何一个状态中。这个栈结构除了可以弹出外，同时也需要支持遍历等（用户可以看到以前修改的每个状态）

**以下内容只是阐述嵌套编辑存在的回溯难点，实际暂时不会实现！**

每个资源组件发再生修改后，都会调用资源回溯的记录器，生成一个资源回溯对象。并且把该对象放在一个该资源组件的回溯栈中。同时每一个操作窗口都会创建一个与之关联的回溯栈（这个栈会记录在对应窗口中生成的资源回溯对象）。此时假定我们存在A、B、C三个资源，其中C资源独立打开，B资源被A引用打开，A资源中引用了BC，其中1窗口打开了A，2窗口打开了B，3窗口打开了C，如下图所示，此时考虑一下场景：

![20221011150325](https://img.jaken.top/image/20221011150325.png)

1. 用户在A中操作了Aa,Ab;在B中操作了Ba,Bb;在C中操作了Ca。此时1窗口的回溯栈包括了Aa,Ab,Ba,Ca,Bb;窗口2的回溯栈包括了Ba,Ca,Bb;窗口3的回溯栈包括了Ca。此时如果在1中撤销2步，此时Ca,Bb。


**此处内容作废**

## 下一步

这里我简单的描述了一下组件的通用能力，接下来我会根据描述把他抽象成对应的类图，并且描述各个组件需要实现的接口以及实现方式。

